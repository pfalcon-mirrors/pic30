11c11
< #define YY_FLEX_SUBMINOR_VERSION 31
---
> #define YY_FLEX_SUBMINOR_VERSION 35
33c33,41
< #if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
---
> #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
> 
> /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
>  * if you want the limit (max/min) macros for int types. 
>  */
> #ifndef __STDC_LIMIT_MACROS
> #define __STDC_LIMIT_MACROS 1
> #endif
> 
48d55
< #endif /* ! C99 */
78a86,87
> #endif /* ! C99 */
> 
88c97,98
< #if __STDC__
---
> /* C99 requires __STDC__ to be defined as 1. */
> #if defined (__STDC__)
92c102
< #endif	/* __STDC__ */
---
> #endif	/* defined (__STDC__) */
133a144,150
> #ifdef __ia64__
> /* On IA-64, the buffer size is 16k, not 8k.
>  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
>  * Ditto for the __ia64__ case accordingly.
>  */
> #define YY_BUF_SIZE 32768
> #else
134a152
> #endif /* __ia64__ */
136a155,158
> /* The state buf must be large enough to hold one state per character in the main buffer.
>  */
> #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
> 
168,172d189
< /* The following is because we cannot portably get our hands on size_t
<  * (without autoconf's help, which isn't available because we want
<  * flex-generated scanners to compile on their own).
<  */
< 
175c192
< typedef unsigned int yy_size_t;
---
> typedef size_t yy_size_t;
270c287
< static int yy_init = 1;		/* whether we need to initialize */
---
> static int yy_init = 0;		/* whether we need to initialize */
586c603
< #line 587 "lex.yy.c"
---
> #line 604 "lex.yy.c"
589a607
> #ifndef YY_NO_UNISTD_H
594a613
> #endif
599a619,649
> static int yy_init_globals (void );
> 
> /* Accessor methods to globals.
>    These are made visible to non-reentrant scanners for convenience. */
> 
> int yylex_destroy (void );
> 
> int yyget_debug (void );
> 
> void yyset_debug (int debug_flag  );
> 
> YY_EXTRA_TYPE yyget_extra (void );
> 
> void yyset_extra (YY_EXTRA_TYPE user_defined  );
> 
> FILE *yyget_in (void );
> 
> void yyset_in  (FILE * in_str  );
> 
> FILE *yyget_out (void );
> 
> void yyset_out  (FILE * out_str  );
> 
> int yyget_leng (void );
> 
> char *yyget_text (void );
> 
> int yyget_lineno (void );
> 
> void yyset_lineno (int line_number  );
> 
633a684,687
> #ifdef __ia64__
> /* On IA-64, the buffer size is 16k, not 8k */
> #define YY_READ_BUF_SIZE 16384
> #else
634a689
> #endif /* __ia64__ */
642c697
< #define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
---
> #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
738c793
< #line 739 "lex.yy.c"
---
> #line 794 "lex.yy.c"
740c795
< 	if ( (yy_init) )
---
> 	if ( !(yy_init) )
742c797
< 		(yy_init) = 0;
---
> 		(yy_init) = 1;
1026c1081
< #line 1027 "lex.yy.c"
---
> #line 1082 "lex.yy.c"
1212c1267
< 			size_t num_to_read =
---
> 			int num_to_read =
1257c1312
< 			(yy_n_chars), num_to_read );
---
> 			(yy_n_chars), (size_t) num_to_read );
1280a1336,1343
> 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
> 		/* Extend the array by 50%, plus the number we really need. */
> 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
> 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
> 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
> 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
> 	}
> 
1696c1759,1761
< 		
---
> 		if ( ! (yy_buffer_stack) )
> 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
> 								  
1713a1779,1780
> 		if ( ! (yy_buffer_stack) )
> 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
1758c1825
<  * @param str a NUL-terminated string to scan
---
>  * @param yystr a NUL-terminated string to scan
1764c1831
< YY_BUFFER_STATE yy_scan_string (yyconst char * str )
---
> YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
1767c1834
< 	return yy_scan_bytes(str,strlen(str) );
---
> 	return yy_scan_bytes(yystr,strlen(yystr) );
1772,1773c1839,1840
<  * @param bytes the byte buffer to scan
<  * @param len the number of bytes in the buffer pointed to by @a bytes.
---
>  * @param yybytes the byte buffer to scan
>  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
1777c1844
< YY_BUFFER_STATE yy_scan_bytes  (yyconst char * bytes, int  len )
---
> YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
1785c1852
< 	n = len + 2;
---
> 	n = _yybytes_len + 2;
1790,1791c1857,1858
< 	for ( i = 0; i < len; ++i )
< 		buf[i] = bytes[i];
---
> 	for ( i = 0; i < _yybytes_len; ++i )
> 		buf[i] = yybytes[i];
1793c1860
< 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
---
> 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
1913a1981,2008
> static int yy_init_globals (void)
> {
>         /* Initialization is the same as for the non-reentrant scanner.
>      * This function is called from yylex_destroy(), so don't allocate here.
>      */
> 
>     (yy_buffer_stack) = 0;
>     (yy_buffer_stack_top) = 0;
>     (yy_buffer_stack_max) = 0;
>     (yy_c_buf_p) = (char *) 0;
>     (yy_init) = 0;
>     (yy_start) = 0;
> 
> /* Defined in main.c */
> #ifdef YY_STDINIT
>     yyin = stdin;
>     yyout = stdout;
> #else
>     yyin = (FILE *) 0;
>     yyout = (FILE *) 0;
> #endif
> 
>     /* For future reference: Set errno on error, since we are called by
>      * yylex_init()
>      */
>     return 0;
> }
> 
1928a2024,2027
>     /* Reset the globals. This is important in a non-reentrant scanner so the next time
>      * yylex() is called, initialization will occur. */
>     yy_init_globals( );
> 
1940c2039
<     	for ( i = 0; i < n; ++i )
---
> 	for ( i = 0; i < n; ++i )
1949c2048
<     	for ( n = 0; s[n]; ++n )
---
> 	for ( n = 0; s[n]; ++n )
1980,1991d2078
< #undef YY_NEW_FILE
< #undef YY_FLUSH_BUFFER
< #undef yy_set_bol
< #undef yy_new_buffer
< #undef yy_set_interactive
< #undef yytext_ptr
< #undef YY_DO_BEFORE_ACTION
< 
< #ifdef YY_DECL_IS_OURS
< #undef YY_DECL_IS_OURS
< #undef YY_DECL
< #endif
